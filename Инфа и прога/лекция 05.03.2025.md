Зачем большое количество данных?
A * B * C
`100*10`      `10*50`      `50*5
A * (B * C)
Cij = сумма от k=0 до m `aik` * `bkj`
`n*k*m`
1. Время работы
2. Пространство
.
1) `100*10*50` + `100*50*5`
2) `10*50*5` + `100*10*5` = `100*5`
Алгоритм Декстера - найти кратчайшее расстояние на графе - O(n^3)
O(`n*E`) E - количество рёбер
for (int i = 0; i < n; ++i)
	p `*=` 2
Анализ сложности - о том как функция растёт
если для любого n>n0 найдётся 0<c1<c2      c1g(n)<f(n)<c2g(n)


Сортировки
1. Время О(nlogn)
2. Память О(1)
3. Устойчивость
<2, a>, <2, b>, <1, c>
<1, c>, <2, a>, <2, b> - устойчивый
<1, c>, <2, b>, <2, a> - неустойчивый
все 3 параметра не могут работать, не более 2
a[j]<a[j-1} - устойчивая
a[j]<a[j-d] - неустойчивая
О(n^2) - простые сортировки
Пузырьком -> быстрая(О(nlogn))
Выбором -> Пирамидальная(О(nlogn))
Вставкой -> Слиянием (O(nlogn)), shell

O(n): Блочная, подсчётом, поразрядная.

for(int i = 0; i < n; i++) {bool fl = false;
	for(int j = n - 1; j > i; j--)
		if(a[j]<a[j-1])
			swap(a[j], a[j-1])
			fl = true;
			}
	if(!fl) break;
}

a[j], a[j-st] - сортировка расчёской
st = N/f
f = 1/(10e^(-fi))
fi = (1+sqrt(5))/2
f = 1.247
st = N/f
st = N/f^2
......
st = N/f^k = 1
k = logf(N)
n = 10
8
6
4
3
2
1
при n = 100
80
64
51
40
32
25
20
16
12
9
7
5
4
3
2
1


Сортировка выбором
8 3 4 1 7 9 2 6
1 3 4 8 7 9 2 6 
1 2 4 8 7 9 3 6
1 2 3 8 7 9 4 6 
1 2 3 4 7 9 8 6 
1 2 3 4 6 9 8 7 
1 2 3 4 6 7 8 9


8 3 4 1 7 9 2 6
1 8 3 4 7 9 2 6



Сортировка вставками
for(int i = 1; i < n; ++i){
	int j = i;
	while(j > 0 && a[j] < a[j-1]){
		swap(a[j], a[j-1]);
		j--;
	}
}
8 3 4 1 7 9 2 6
до i-ой позиции всё отсортировано
i+1 ставим на своё место 
3 8 4 1 7 9 2 6 i = 1
3 4 8 1 7 9 2 6 i = 2
3 4 1 8 7 9 2 6 i = 3
3 1 4 8 7 9 2 6 
1 3 4 8 7 9 2 6
1 3 4 7 8 9 2 6 i = 4
i = 5
.....
1 3 4 7 8 2 9 6 i = 7
1 3 4 7 2 8 9 6
1 3 4 2 7 8 9 6
1 3 2 4 7 8 9 6
1 2 3 4 7 8 9 6
1 2 3 4 7 8 6 9 i = 8
1 2 3 4 7 6 8 9
1 2 3 4 6 7 8 9

9 2 1 0 3 1 6 8 4 5 7
		лучший            худший                средний
пузырёк   55 0                  55 45                    55 22
выбор      63 0                   63 9                     63 6
вставками  10 0                 55 45                   32 22
Лучше пользоваться вставкой
Блочная сортировка: разложение тетрадей в алфавитном порядке

12, 3, 45, 14, 21, 37, 48, 6, 36, 52, 0
p = 5
m = (min - max)/p      k = (x - min)/m
0   0 ... 9        3, 6, 0
1   10 ... 19    12, 14
2   20 ... 29     21
3   30 ... 39     37, 36
4   40 ... max   45, 48, 52

Специфическая сортировка
k = max-min << n
1, 2, 3, 1, 1, 2, 2, 3, 2, 1, 4, 4, 1, 5, 4, 5, 1, 2, 1, 2, 1, 3, 4, 5, 1
x-min
0 1 2 3 4
8 6 3 4 3
(min + i)
1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5
